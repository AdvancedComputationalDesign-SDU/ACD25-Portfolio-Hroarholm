---
layout: default
title: Project Documentation
parent: "A3: Parametric Structural Canopy"
nav_order: 2
nav_exclude: false
search_exclude: false
---

# Assignment 3: Parametric Structural Canopy

[View on GitHub]({{ site.github.repository_url }})

---
## Pseudo-code Overview

The computational pipeline follows the steps below:

1. Initialize parameters and random seed
   A single global random seed is set to ensure reproducibility of both heightmap noise and recursive branching behavior.

2. Generate UV sampling grid
   A uniform UV grid is created over the [0,1]×[0,1] domain and later remapped to the surface domain.

3. Compute heightmap
   A continuous scalar field is generated using sinusoidal functions.  
   Parameters such as amplitude, frequency, phase, and noise control the vertical displacement of the canopy.

4. Construct NURBS surface
   The heightmap is mapped onto a point grid and converted into a NURBS surface.

5. **Sample surface and compute curvature*
   The surface is uniformly sampled in UV space. Gaussian curvature is evaluated at each sample point.

6. Tessellate canopy into panels
   The sampled grid is converted into quad panels.  
   Average curvature per panel is computed and used to control panel openings.

7. Cull and open panels  
   Panels below a curvature threshold are removed, producing spatial variation across the canopy.

8. Select support anchor points  
   The lowest surface points are identified and projected downward to define support base locations.  
   Anchors closer than a minimum distance are removed.

9. Generate recursive branching supports 
   From each anchor point, a recursive branching structure is grown.  
   Branch length, angle, depth, and randomness are parameterized.  
   Base cases terminate recursion at a fixed depth.

10. Attach supports to canopy 
    Final-level branches snap to the nearest canopy grid point to ensure geometric continuity.

11. Apply thickness and color mapping
    Branches are thickened using mesh pipes, with the radius decreasing per level of recursion.  
    Colours are assigned based on branching depth.

---

## Technical Explanation
The canopy geometry is generated by a heightmap evaluated in UV space and mapped onto a NURBS surface.  
The use of sinusoidal functions allows smooth, continuous surface modulation while remaining computationally lightweight and parametric.

Tessellation is performed by subdividing the sampled surface grid into quad panels.  
Gaussian curvature is used as a geometric signal to control panel openings, allowing ridges to remain open while valleys are closed.  
This creates a structurally and visually differentiated canopy surface.

Structural supports are generated using recursive branching logic inspired by botanical growth systems.  
Each support begins with a vertical trunk and branches recursively with decreasing length and radius.  
Random variation is introduced in branch orientation, while a global seed ensures reproducibility.  
Final branches are snapped to the canopy surface to avoid gaps and ensure structural continuity.

All major design parameters (surface resolution, heightmap behavior, panel thresholds, branching depth, and randomness) are exposed as Grasshopper inputs, enabling controlled exploration of design variants.

---

## Examples of variations of the canopy.
Below are some iterations of the canopy design.

### Design Variants – Parameter Comparison

| Parameter | Design A | Design B | Design C |
|---------|---------|---------|---------|
| Seed | 47 | 47 | 47 |
| divU / divV | 30 / 30 | 40 / 60 | 20 / 40 |
| Amplitude | 2.0 | 1.5 | 1.8 |
| Frequency | 1.3 | 2.0 | 1.5 |
| Panel threshold | 0.75 | 0.85 | 0.82 |
| Trunk length | 8 | 8 | 8 |
| Branch levels | 2 | 2 | 3 |
| Branch count (lvl 1) | 2–2 | 3–3 | 3–5 |
| Randomness | 1.0 | 1.0 | 1.0 |
| Trunk radius | 0.3 | 0.3 | 0.3 |
| Branch reduction | 0.5 | 0.5 | 0.5 |

The three design variants are generated using the same global random seed to ensure reproducibility.  
Variations are produced by changing surface resolution, heightmap parameters, panel opening thresholds, and recursive branching depth.

### Design A

**Design A** Variation with a canopy with lower surface frequency and evenly spaced supports.

![View1](images/01_View1.png)

![View1](images/01_View2.png)

![View1](images/01_Settings.png)


### Design B

**Design B** Increased surface resolution and curvature sensitivity, resulting in denser panel openings and a more articulated canopy. 

![View1](images/02_View1.png)

![View1](images/02_View2.png)

![View1](images/02_Settings.png)

### Design C

**Design C** Reduced surface resolution but increased branching depth, resulting in a heavier structural expression.

![View1](images/03_View1.png)

![View1](images/03_View2.png)

![View1](images/03_Settings.png)

---

## AI Aknowledgements

I have used AI extensively.

As I progressed in working with this assignment, I have been more thoughtfull on how to prompt.

My prompting have become more specific on what kind of tool I want to use for a specific task, 
more than what task I need assistance in completing.

Below are some examples of the most recent prompts.

1.
So I have some issues with the getting the lowest points from the surface. So I have several local minimaz, where I want the fractal trees to grow. However I just want one tree for each dip, but get several numbers at each local minima. I need to cull some points at each minima, so I only have one tree at each minima.
I expect it to be some kind of distance to nearby points.

2.
So I have the grid but I need to make some kind of panelisation. Each quad should have some kind of opening. The opening should be based on its placement along the surface. I want to analyze the surface curvature for the double derivative. If panel is on the ridge, it should it be the most open. If its in or close to a valley, it should be closed.

3.
This still generates small panel openings on valleys. I want to remove the smallest panels openings based on a cull function or something similar. The function should be controlled by an grasshopper input, which controls a threshold of the size of panels to be removed. The input should be placed in configuration part of my code.

4.
So with this panelisation. Each panel should be enumerated right. So both the initial quad and this secondary quad shares numbers?

5.
With every base_quad numbered and paired with K numbers for its slope, lets color the quads based on the their K value.

6.
I need to add some thickness to my trees and branches. The trunk should have one size, then each branch gets a reduction, that should be controllable. This control, one for the starting trunk size and one for the level of reduction of branches. should be an input, that can also be written in the configuration part of the code. I imagine the trunk size input is radius based and can be controlled with a slider. I imagine the reduction is a multiplyer input, in the range 0.5 to 0.95. I imagine the function using some kind of mesh piping for keeping it simple, yet fast for modelling several branches in an iterative design process. There should also be an option for coloring, so each division gets a new color.

### Additional
Besides prompts like above, ChatGPT have been used to specify how to order the script in a more meaning full way with sections, when I lost a bit of track of my code myself.

## Aknowledgements
The UV grid generation originates from the lecture and my instructor Özgüç Bertug Çapunaman.